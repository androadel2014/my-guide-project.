// =====================
// Community: Places & Groups (CRUD)
// ✅ FIX: moderation + search + NO "where" before declaration
// =====================

// Helper: run sqlite safely (promise)
function run(db, sql, params = []) {
  return new Promise((resolve, reject) => {
    db.run(sql, params, function (err) {
      if (err) reject(err);
      else resolve(this);
    });
  });
}
function all(db, sql, params = []) {
  return new Promise((resolve, reject) => {
    db.all(sql, params, (err, rows) => {
      if (err) reject(err);
      else resolve(rows || []);
    });
  });
}
function get(db, sql, params = []) {
  return new Promise((resolve, reject) => {
    db.get(sql, params, (err, row) => {
      if (err) reject(err);
      else resolve(row || null);
    });
  });
}

async function ensureCommunityTables() {
  await run(
    db,
    `CREATE TABLE IF NOT EXISTS community_places (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      category TEXT,
      state TEXT,
      city TEXT,
      address TEXT,
      phone TEXT,
      website TEXT,
      notes TEXT,
      status TEXT,
      created_by INTEGER,
      reviewed_by INTEGER,
      reviewed_at TEXT,
      created_at TEXT DEFAULT (datetime('now')),
      updated_at TEXT DEFAULT (datetime('now'))
    )`
  );

  await run(
    db,
    `CREATE TABLE IF NOT EXISTS community_groups (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      platform TEXT,
      link TEXT,
      state TEXT,
      city TEXT,
      topic TEXT,
      notes TEXT,
      status TEXT,
      created_by INTEGER,
      reviewed_by INTEGER,
      reviewed_at TEXT,
      created_at TEXT DEFAULT (datetime('now')),
      updated_at TEXT DEFAULT (datetime('now'))
    )`
  );

  // if tables existed earlier, add missing cols safely
  safeAlterTable(`ALTER TABLE community_places ADD COLUMN category TEXT`);
  safeAlterTable(`ALTER TABLE community_places ADD COLUMN state TEXT`);
  safeAlterTable(`ALTER TABLE community_places ADD COLUMN city TEXT`);
  safeAlterTable(`ALTER TABLE community_places ADD COLUMN address TEXT`);
  safeAlterTable(`ALTER TABLE community_places ADD COLUMN phone TEXT`);
  safeAlterTable(`ALTER TABLE community_places ADD COLUMN website TEXT`);
  safeAlterTable(`ALTER TABLE community_places ADD COLUMN notes TEXT`);
  safeAlterTable(`ALTER TABLE community_places ADD COLUMN created_at TEXT`);
  safeAlterTable(`ALTER TABLE community_places ADD COLUMN updated_at TEXT`);
  safeAlterTable(`ALTER TABLE community_places ADD COLUMN status TEXT`);
  safeAlterTable(`ALTER TABLE community_places ADD COLUMN created_by INTEGER`);
  safeAlterTable(`ALTER TABLE community_places ADD COLUMN reviewed_by INTEGER`);
  safeAlterTable(`ALTER TABLE community_places ADD COLUMN reviewed_at TEXT`);

  safeAlterTable(`ALTER TABLE community_groups ADD COLUMN platform TEXT`);
  safeAlterTable(`ALTER TABLE community_groups ADD COLUMN link TEXT`);
  safeAlterTable(`ALTER TABLE community_groups ADD COLUMN state TEXT`);
  safeAlterTable(`ALTER TABLE community_groups ADD COLUMN city TEXT`);
  safeAlterTable(`ALTER TABLE community_groups ADD COLUMN topic TEXT`);
  safeAlterTable(`ALTER TABLE community_groups ADD COLUMN notes TEXT`);
  safeAlterTable(`ALTER TABLE community_groups ADD COLUMN created_at TEXT`);
  safeAlterTable(`ALTER TABLE community_groups ADD COLUMN updated_at TEXT`);
  safeAlterTable(`ALTER TABLE community_groups ADD COLUMN status TEXT`);
  safeAlterTable(`ALTER TABLE community_groups ADD COLUMN created_by INTEGER`);
  safeAlterTable(`ALTER TABLE community_groups ADD COLUMN reviewed_by INTEGER`);
  safeAlterTable(`ALTER TABLE community_groups ADD COLUMN reviewed_at TEXT`);
}

// ---------------------
// Places (CRUD)
// ---------------------
app.get("/api/community/places", authOptional, async (req, res) => {
  try {
    const { q = "", state = "", city = "", category = "" } = req.query;

    const where = [];
    const params = [];

    // moderation: public sees only approved
    const isAdmin = isAdminReq(req);
    // if (!isAdmin) {
    where.push(`COALESCE(status,'approved') = 'approved'`);
    // }

    if (String(q).trim()) {
      where.push("(name LIKE ? OR notes LIKE ? OR address LIKE ?)");
      params.push(`%${q.trim()}%`, `%${q.trim()}%`, `%${q.trim()}%`);
    }
    if (state) {
      where.push("state = ?");
      params.push(state);
    }
    if (String(city).trim()) {
      where.push("LOWER(city) = LOWER(?)");
      params.push(String(city).trim());
    }
    if (category) {
      where.push("category = ?");
      params.push(category);
    }

    const sql = `
  SELECT
    p.*,
    COALESCE(AVG(r.stars), 0) AS avg_rating,
    COUNT(r.id) AS reviews_count
  FROM community_places p
  LEFT JOIN place_reviews r
    ON r.place_id = p.id
  ${where.length ? `WHERE ${where.join(" AND ")}` : ""}
  GROUP BY p.id
  ORDER BY p.id DESC
`;

    const rows = await all(db, sql, params);
    res.json(rows);
  } catch (e) {
    console.error(e);
    res.status(500).json({ error: "Failed to load places" });
  }
});

app.get("/api/community/places/:id", authOptional, async (req, res) => {
  try {
    const id = toInt(req.params.id);
    if (!id) return res.status(400).json({ error: "Bad id" });

    const row = await get(
      db,
      `
      SELECT
        p.*,
        COALESCE(AVG(r.stars), 0) AS avg_rating,
        COUNT(r.id) AS reviews_count
      FROM community_places p
      LEFT JOIN place_reviews r ON r.place_id = p.id
      WHERE p.id = ?
      GROUP BY p.id
      LIMIT 1
      `,
      [id]
    );

    if (!row) return res.status(404).json({ error: "Not found" });
    res.json(row);
  } catch (e) {
    console.error(e);
    res.status(500).json({ error: "Failed" });
  }
});

app.post("/api/community/places", authRequired, async (req, res) => {
  try {
    const {
      name,
      category = "",
      state = "",
      city = "",
      address = "",
      phone = "",
      website = "",
      notes = "",
    } = req.body || {};

    if (!name || !String(name).trim())
      return res.status(400).json({ error: "Name is required" });

    // default moderation: pending (until admin approves)
    const status = "approved";

    const r = await run(
      db,
      `INSERT INTO community_places (name, category, state, city, address, phone, website, notes, status, created_by)
       VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      [
        String(name).trim(),
        category,
        state,
        String(city || "").trim(),
        String(address || "").trim(),
        String(phone || "").trim(),
        String(website || "").trim(),
        String(notes || "").trim(),
        status,
        req.user.id,
      ]
    );

    const created = await get(
      db,
      `SELECT * FROM community_places WHERE id = ?`,
      [r.lastID]
    );
    res.json(created);
  } catch (e) {
    console.error(e);
    res.status(500).json({ error: "Failed to create place" });
  }
});

async function updatePlace(req, res) {
  try {
    const id = req.params.id;
    const existing = await get(
      db,
      `SELECT * FROM community_places WHERE id = ?`,
      [id]
    );
    if (!existing) return res.status(404).json({ error: "Not found" });

    const b = req.body || {};
    const next = {
      name: b.name ?? existing.name,
      category: b.category ?? existing.category,
      state: b.state ?? existing.state,
      city: b.city ?? existing.city,
      address: b.address ?? existing.address,
      phone: b.phone ?? existing.phone,
      website: b.website ?? existing.website,
      notes: b.notes ?? existing.notes,
    };

    if (!String(next.name || "").trim())
      return res.status(400).json({ error: "Name is required" });

    await run(
      db,
      `UPDATE community_places
       SET name=?, category=?, state=?, city=?, address=?, phone=?, website=?, notes=?, updated_at=datetime('now')
       WHERE id=?`,
      [
        String(next.name).trim(),
        next.category || "",
        next.state || "",
        String(next.city || "").trim(),
        String(next.address || "").trim(),
        String(next.phone || "").trim(),
        String(next.website || "").trim(),
        String(next.notes || "").trim(),
        id,
      ]
    );

    const updated = await get(
      db,
      `SELECT * FROM community_places WHERE id = ?`,
      [id]
    );
    res.json(updated);
  } catch (e) {
    console.error("updatePlace error:", e);
    res.status(500).json({ error: String(e?.message || "Failed to update") });
  }
}

app.put("/api/community/places/:id", authRequired, updatePlace);
app.patch("/api/community/places/:id", authRequired, updatePlace);

app.delete("/api/community/places/:id", authRequired, async (req, res) => {
  try {
    const id = req.params.id;
    const existing = await get(
      db,
      `SELECT * FROM community_places WHERE id = ?`,
      [id]
    );
    if (!existing) return res.status(404).json({ error: "Not found" });

    await run(db, `DELETE FROM community_places WHERE id = ?`, [id]);
    res.json({ ok: true });
  } catch (e) {
    console.error(e);
    res.status(500).json({ error: "Failed to delete place" });
  }
});

// ---------------------
// Groups (CRUD)
// ---------------------
app.get("/api/community/groups", authOptional, async (req, res) => {
  try {
    const {
      q = "",
      state = "",
      city = "",
      platform = "",
      topic = "",
    } = req.query;

    const where = [];
    const params = [];

    // moderation: public sees only approved
    const isAdmin = isAdminReq(req);
    // if (!isAdmin) {
    where.push(`COALESCE(status,'approved') = 'approved'`);
    // }

    if (String(q).trim()) {
      where.push("(name LIKE ? OR notes LIKE ?)");
      params.push(`%${q.trim()}%`, `%${q.trim()}%`);
    }
    if (state) {
      where.push("state = ?");
      params.push(state);
    }
    if (String(city).trim()) {
      where.push("LOWER(city)=LOWER(?)");
      params.push(String(city).trim());
    }
    if (platform) {
      where.push("platform = ?");
      params.push(platform);
    }
    if (topic) {
      where.push("topic = ?");
      params.push(topic);
    }

    const sql =
      `SELECT * FROM community_groups ` +
      (where.length ? `WHERE ${where.join(" AND ")} ` : "") +
      `ORDER BY id DESC`;

    const rows = await all(db, sql, params);
    res.json(rows);
  } catch (e) {
    console.error(e);
    res.status(500).json({ error: "Failed to load groups" });
  }
});

app.get("/api/community/groups/:id", authOptional, async (req, res) => {
  try {
    const row = await get(db, `SELECT * FROM community_groups WHERE id = ?`, [
      req.params.id,
    ]);
    if (!row) return res.status(404).json({ error: "Not found" });
    res.json(row);
  } catch (e) {
    console.error(e);
    res.status(500).json({ error: "Failed" });
  }
});

app.post("/api/community/groups", authRequired, async (req, res) => {
  try {
    const {
      name,
      platform = "",
      link = "",
      state = "",
      city = "",
      topic = "",
      notes = "",
    } = req.body || {};

    if (!name || !String(name).trim())
      return res.status(400).json({ error: "Name is required" });
    if (!link || !String(link).trim())
      return res.status(400).json({ error: "Link is required" });

    // default moderation: pending
    const status = "approved";

    const r = await run(
      db,
      `INSERT INTO community_groups (name, platform, link, state, city, topic, notes, status, created_by)
       VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      [
        String(name).trim(),
        platform,
        String(link).trim(),
        state,
        String(city || "").trim(),
        topic,
        String(notes || "").trim(),
        status,
        req.user.id,
      ]
    );

    const created = await get(
      db,
      `SELECT * FROM community_groups WHERE id = ?`,
      [r.lastID]
    );
    res.json(created);
  } catch (e) {
    console.error(e);
    res.status(500).json({ error: "Failed to create group" });
  }
});

async function updateGroup(req, res) {
  try {
    const id = req.params.id;
    const existing = await get(
      db,
      `SELECT * FROM community_groups WHERE id = ?`,
      [id]
    );
    if (!existing) return res.status(404).json({ error: "Not found" });

    const b = req.body || {};
    const next = {
      name: b.name ?? existing.name,
      platform: b.platform ?? existing.platform,
      link: b.link ?? existing.link,
      state: b.state ?? existing.state,
      city: b.city ?? existing.city,
      topic: b.topic ?? existing.topic,
      notes: b.notes ?? existing.notes,
    };

    if (!String(next.name || "").trim())
      return res.status(400).json({ error: "Name is required" });
    if (!String(next.link || "").trim())
      return res.status(400).json({ error: "Link is required" });

    await run(
      db,
      `UPDATE community_groups
       SET name=?, platform=?, link=?, state=?, city=?, topic=?, notes=?, updated_at=datetime('now')
       WHERE id=?`,
      [
        String(next.name).trim(),
        next.platform || "",
        String(next.link).trim(),
        next.state || "",
        String(next.city || "").trim(),
        next.topic || "",
        String(next.notes || "").trim(),
        id,
      ]
    );

    const updated = await get(
      db,
      `SELECT * FROM community_groups WHERE id = ?`,
      [id]
    );
    res.json(updated);
  } catch (e) {
    console.error("updateGroup error:", e);
    res.status(500).json({ error: String(e?.message || "Failed to update") });
  }
}
app.put("/api/community/groups/:id", authRequired, updateGroup);
app.patch("/api/community/groups/:id", authRequired, updateGroup);

app.delete("/api/community/groups/:id", authRequired, async (req, res) => {
  try {
    const id = req.params.id;
    const existing = await get(
      db,
      `SELECT * FROM community_groups WHERE id = ?`,
      [id]
    );
    if (!existing) return res.status(404).json({ error: "Not found" });

    await run(db, `DELETE FROM community_groups WHERE id = ?`, [id]);
    res.json({ ok: true });
  } catch (e) {
    console.error(e);
    res.status(500).json({ error: "Failed to delete group" });
  }
});

// =====================
// Community Places Reviews (SQLite) — FIXED ORDER + WRAPPERS
// =====================

// 1) ensure reviews table exists AFTER community_places is created
async function ensurePlaceReviewsTable() {
  await run(
    db,
    `CREATE TABLE IF NOT EXISTS place_reviews (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      place_id INTEGER NOT NULL,
      user_id INTEGER,
      name TEXT NOT NULL,
      stars INTEGER NOT NULL,
      text TEXT NOT NULL,
      created_at TEXT DEFAULT (datetime('now')),
      FOREIGN KEY(place_id) REFERENCES community_places(id) ON DELETE CASCADE
    )`
  );

  await run(
    db,
    `CREATE INDEX IF NOT EXISTS idx_place_reviews_place
     ON place_reviews(place_id)`
  );

  // ✅ 1) Clean duplicates BEFORE unique index
  // Keep the latest review (max id) for each (place_id, user_id) and delete the rest
  await run(
    db,
    `
    DELETE FROM place_reviews
    WHERE id NOT IN (
      SELECT MAX(id)
      FROM place_reviews
      WHERE user_id IS NOT NULL
      GROUP BY place_id, user_id
    )
    AND user_id IS NOT NULL
    `
  );

  // ✅ 2) Now it's safe to add UNIQUE constraint
  await run(
    db,
    `CREATE UNIQUE INDEX IF NOT EXISTS idx_place_reviews_unique
     ON place_reviews(place_id, user_id)`
  );
}

// ✅ IMPORTANT: call it after ensureCommunityTables finishes

// 2) GET reviews for a community place
app.get("/api/community/places/:id/reviews", authOptional, (req, res) => {
  const placeId = toInt(req.params.id);
  if (!placeId) return res.status(400).json({ error: "Bad place id" });

  dbAll(
    `
    SELECT
      pr.id,
      pr.place_id,
      pr.user_id,
      COALESCE(u.username, pr.name) AS user_name,
      pr.stars,
      pr.text,
      pr.created_at
    FROM place_reviews pr
    LEFT JOIN users u ON u.id = pr.user_id
    WHERE pr.place_id = ?
    ORDER BY pr.id DESC
    `,
    [placeId],
    (err, rows) => {
      if (err) return res.status(500).json({ error: "DB error" });
      return res.json(rows || []);
    }
  );
});

// 3) POST review for a community place
app.post("/api/community/places/:id/reviews", authRequired, (req, res) => {
  const placeId = toInt(req.params.id);
  if (!placeId) return res.status(400).json({ error: "Bad place id" });

  const text = safeTrim(req.body?.text);
  const stars = Number(req.body?.stars);

  if (!text) return res.status(400).json({ error: "text required" });
  if (!(stars >= 1 && stars <= 5))
    return res.status(400).json({ error: "stars must be 1..5" });

  // ✅ تأكد المكان موجود
  dbGet(
    `SELECT id FROM community_places WHERE id = ?`,
    [placeId],
    (e0, row) => {
      if (e0) return res.status(500).json({ error: "DB error" });
      if (!row) return res.status(404).json({ error: "Place not found" });

      // ✅ اسم اليوزر يتجاب من DB (مش من الbody)
      dbGet(
        `SELECT username FROM users WHERE id = ?`,
        [req.user.id],
        (eU, uRow) => {
          if (eU) return res.status(500).json({ error: "DB error" });

          const userName = safeTrim(uRow?.username) || `User ${req.user.id}`;

          // ✅ تقييم واحد لكل يوزر لكل مكان (Upsert)
          dbRun(
            `
            INSERT INTO place_reviews (place_id, user_id, name, stars, text, created_at)
            VALUES (?, ?, ?, ?, ?, datetime('now'))
            ON CONFLICT(place_id, user_id) DO UPDATE SET
              name = excluded.name,
              stars = excluded.stars,
              text = excluded.text,
              created_at = datetime('now')
            `,
            [placeId, req.user.id, userName, Math.round(stars), text],
            function (err) {
              if (err) return res.status(500).json({ error: "DB error" });
              return res.status(201).json({ ok: true });
            }
          );
        }
      );
    }
  );
});

function normalizeCvResponse(row) {
  const parsed = safeJsonParse(row.cv_data);
  return {
    id: row.id,
    cv_name: row.cv_name,
    updated_at: row.updated_at,
    cv_data: parsed || row.cv_data,
  };
}

function toInt(v) {
  const n = Number(v);
  return Number.isInteger(n) && n > 0 ? n : null;
}

// 4) DELETE my review for a community place
app.delete("/api/community/places/:id/reviews/me", authRequired, (req, res) => {
  const placeId = toInt(req.params.id);
  if (!placeId) return res.status(400).json({ error: "Bad place id" });

  dbRun(
    `DELETE FROM place_reviews WHERE place_id = ? AND user_id = ?`,
    [placeId, req.user.id],
    function (err) {
      if (err) return res.status(500).json({ error: "DB error" });
      return res.json({ ok: true, deleted: this.changes || 0 });
    }
  );
});

/* =====================
   ✅ helpers for flexible ids
===================== */
function parseAnyPostId(raw) {
  const s = safeTrim(raw || "");
  if (!s) return { kind: "bad" };

  if (s.startsWith("p_")) {
    const id = toInt(s.slice(2));
    return id ? { kind: "feed", id } : { kind: "bad" };
  }
  if (s.startsWith("pp_")) {
    const id = toInt(s.slice(3));
    return id ? { kind: "profile", id } : { kind: "bad" };
  }

  // numeric (unknown: could be feed OR profile)
  const id = toInt(s);
  return id ? { kind: "numeric", id } : { kind: "bad" };
}
